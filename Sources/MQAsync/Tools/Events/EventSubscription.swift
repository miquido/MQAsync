public struct EventSubscription<Event>
where Event: EventDescription {

	// there is some serious memory management issue
	// in code generated by swift which causes
	// runtime crash on cascade deinit calls
	// when this refrence is using ARC, holding Unmanaged
	// solves the issue in Swift 5.9
	private var futureEvent: Unmanaged<EventList<Event>.FutureEvent>
	#if DEBUG
	private var waiting: Bool = false
	#endif

	@usableFromInline internal init(
		futureEvent: EventList<Event>.FutureEvent
	) {
		self.futureEvent = .passRetained(futureEvent)
	}
}

extension EventSubscription: Sendable {}

extension EventSubscription {

	public mutating func nextEvent() async throws -> Event.Payload {
		#if DEBUG
		assert(!self.waiting, "Can't wait more than once!")
		self.waiting = true
		defer { self.waiting = false }
		#endif
		let event: EventList<Event>.Event = try await self.futureEvent.takeUnretainedValue().futureEvent()
		self.futureEvent.release()
		self.futureEvent = .passRetained(event.futureEvent)
		return event.payload
	}

	public mutating func flushEvents() {
		#if DEBUG
		assert(!self.waiting, "Can't wait more than once!")
		self.waiting = true
		defer { self.waiting = false }
		#endif
		while let event: EventList<Event>.Event = self.futureEvent.takeUnretainedValue().momentaryEvent {
			self.futureEvent.release()
			self.futureEvent = .passRetained(event.futureEvent)
		}
	}
}
